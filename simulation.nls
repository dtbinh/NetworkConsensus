;----------------------------------------------------------------------------;
;                                                                            ;
;    NetworkConsensus - SIMULATION MODULE                                    ;
;                                                                            ;
;    Authors:                                                                ;
;        Leonardo Mizoguti                                                   ;
;        Man Hue Tran Diep                                                   ;
;        Thierry Fosso Kenne                                                 ;
;                                                                            ;
;    Coordinator:                                                            ;
;        Ada Diaconescu                                                      ;
;                                                                            ;
;----------------------------------------------------------------------------;

to-report simulate-varying-agents
  
  let simulation-result ifelse-value (is-vary-eps?) [simulate-varying-epsilon][simulate]
  
  if simulation-result [
      if (is-vary-eps?) [ set eps min-eps set epsilon eps ]
      set agt (agt + step-agents)
      if agt > max-agents [ report true ]
      set number-of-agents agt
      edit-group nobody
      reset-ticks
  ]
  report false

end

to-report simulate-varying-epsilon
  if simulate [
    set eps precision (eps + step-eps) ((-1) * floor(log step-eps 10))
    if eps > max-eps [ report true ]
    set epsilon eps
    setup-influence-links-weight
    adjust-agent-type-properties
    reset-ticks
  ]
  report false
  
end

to-report simulate
    
  setup-influence-links-weight
  if not check-weights [ report-error 2 stop ]
  
  let convergence (([self-val] of max-one-of turtles [self-val]) - ([self-val] of min-one-of turtles [self-val]))
 
  ;eval convergence and decide whether or not to go on
  ifelse convergence >= convergence-precision 
  [
    ;type "at ticks: " type ticks print ": " ask turtle 0 [type "self-val of a0: " show self-val] ask turtle 1 [type "self-val of a1: " show self-val]
    
    ask turtles [ 
      update-in-vals  
    ]
    ask turtles[
      update-self-val
    ]
    display-labels
   
    tick
    
    report false
    
  ]
  [
    print-results 
    ;type "end of test for epsilon: " print epsilon
    report true 
  ]
 
end

to validate-simulation
  set printed-head false
  ; validate network and simulation options to avoid inconsistencies   
  if (validate-network and validate-simulation-options) [
    adjust-agent-type-properties
    display-labels
    reset-ticks
  ]
  
end

to-report validate-network
  
  ; check if network is connected
  if nw:mean-path-length = false [ report-error 1 report false ]
   
  report true
  
end

to-report check-weights
  ask turtles[
    let in-weight-sum get-in-neighbour-weights
    set in-weight-sum (in-weight-sum + self-weight)
    ;type "check-weights: agent " type [who] of self type ": " type in-weight-sum print ""  
    if in-weight-sum != 1[
      ;type "Warning --> check-weights: agent " type [who] of self type ": " type in-weight-sum type ". should be 1." print "" 
      report-error 2
      report false
    ]
    
    ;type "sum-in-weights: agent " type [who] of self type ": " type get-in-neighbour-weights print ""
    ;type "self-weight: agent " type [who] of self type ": " type self-weight print "" 
  ]
  report true
end

to go
  
  ifelse (is-vary-agents?) [ if simulate-varying-agents [ stop ] ]
  [
    ifelse (is-vary-eps?) [ if simulate-varying-epsilon [ stop ] ] 
    [ 
      if simulate [ stop ]
    ]
  ]
 
end

to update-in-vals 
  ;set in-vals sum [self-val] of in-influence-link-neighbors ; my-in-influence-links 
  set in-vals 0
  let neighbor-impact 0 
  let neighbour-weight 0
  let neighbour-self-val 0
  foreach sort in-influence-link-neighbors [ 
    set neighbour-weight [weight] of (in-influence-link-from ?)
    set neighbour-self-val [self-val] of ? 
    set neighbor-impact (neighbour-self-val * neighbour-weight)
    set in-vals (in-vals + neighbor-impact) 
  ]
  ;type "agent " type [who] of self type " has in-vals: " type [in-vals] of self print ""
end

to update-self-val
  let old-self-val self-val
  set self-val (in-vals + (old-self-val * self-weight))
  
  let redness 255 * (self-val - other's-value) / (head's-value - other's-value)
  let blueness 255 * (head's-value - self-val) / (head's-value - other's-value)
  set color rgb redness 0 blueness
  ;type "agent " type [who] of self type " has self-val: " type [self-val] of self print ""
end

to-report validate-simulation-options
  
  if (is-vary-agents?) [
    set agt min-agents
    set number-of-agents agt
    edit-group nobody
  ]
  
  if (is-vary-eps?) [
    set eps min-eps
    set epsilon eps
  ]
  
  report true
  
end

;----------------------------------------------------------------------------;
;    Weights setup                                                           ;
;----------------------------------------------------------------------------;

; Calculates the weight of each node and link in the network

to setup-influence-links-weight 
  let head-weight (1 - epsilon)
  let others-weight epsilon
 
  let norm 0
  let count-of-neighbors 0
  
  ask turtles with [agent-type = 1] [
    let this-turtle self
    set count-of-neighbors count my-in-influence-links
    set norm head-weight
    ask my-in-influence-links [
      let stubbornness precision (1 - theta * abs (([self-val] of end1 - [self-val] of end2) / (head's-value - other's-value))) 2
      set norm norm + stubbornness * (others-weight / count-of-neighbors)
    ]
    ask my-in-influence-links [
      let stubbornness precision (1 - theta * abs (([self-val] of end1 - [self-val] of end2) / (head's-value - other's-value))) 2
      set weight precision (stubbornness * (others-weight / count-of-neighbors) / norm) 100 
    ]
  ]
  
  ask turtles with [agent-type = 0] [
    let this-turtle self
    set count-of-neighbors count my-in-influence-links
    set norm 0
    
    ; Retrieve links
    let links-from-head my-in-influence-links with [ [agent-type] of end1 = 1 ]
    let links-from-others my-in-influence-links with [ [agent-type] of end1 = 0 ]
    
    set norm (head-weight * count links-from-head) + (others-weight * count links-from-others)
    set norm norm + ifelse-value (agent-type = 1) [head-weight][others-weight]
    ask links-from-head [ set weight precision (head-weight / norm) 100 ]
    ask links-from-others [ set weight precision (others-weight / norm) 100 ]
    set norm (1 - get-in-neighbour-weights)
    
    ; Calculate second norm considering stubbornness
    ask links-from-head [
      let stubbornness precision (1 - theta * abs (([self-val] of end1 - [self-val] of end2) / (head's-value - other's-value))) 2
      set norm norm + stubbornness * weight
    ]
    ask links-from-others [ 
      let stubbornness precision (1 - theta * abs (([self-val] of end1 - [self-val] of end2) / (head's-value - other's-value))) 2
      set norm norm + stubbornness * weight
    ]
 
    ; Calculate weights
    ask links-from-head [
      let stubbornness precision (1 - theta * abs (([self-val] of end1 - [self-val] of end2) / (head's-value - other's-value))) 2
      set weight precision (stubbornness * weight / norm) 100 
    ]
    ask links-from-others [
      let stubbornness precision (1 - theta * abs (([self-val] of end1 - [self-val] of end2) / (head's-value - other's-value))) 2
      set weight precision (stubbornness * weight / norm) 100 
    ]
 
 
 
    
;    ; Calculate norm considering stubbornness
;    ask links-from-head [
;      let stubbornness precision (1 - theta * abs (([self-val] of end1 - [self-val] of end2) / (head's-value - other's-value))) 2
;      set norm norm + stubbornness * head-weight
;    ]
;    ask links-from-others [ 
;      let stubbornness precision (1 - theta * abs (([self-val] of end1 - [self-val] of end2) / (head's-value - other's-value))) 2
;      set norm norm + stubbornness * others-weight
;    ]
;    set norm norm + others-weight
;    
;    ; Calculate weights
;    ask links-from-head [
;      let stubbornness precision (1 - theta * abs (([self-val] of end1 - [self-val] of end2) / (head's-value - other's-value))) 2
;      set weight precision (stubbornness * head-weight / norm) 100 
;    ]
;    ask links-from-others [
;      let stubbornness precision (1 - theta * abs (([self-val] of end1 - [self-val] of end2) / (head's-value - other's-value))) 2
;      set weight precision (stubbornness * others-weight / norm) 100 
;    ]
  ]
  
;  Modèle normalisé
;  ask turtles [
;    let this-turtle self
;    set count-of-neighbors count my-in-influence-links
;    let links-from-head my-in-influence-links with [ [agent-type] of end1 = 1 ]
;    let links-from-others my-in-influence-links with [ [agent-type] of end1 = 0 ]
;    set norm (head-weight * count links-from-head) + (others-weight * count links-from-others)
;    set norm norm + ifelse-value (agent-type = 1) [head-weight][others-weight]
;    ask links-from-head [ set weight precision (head-weight / norm) 100 ]
;    ask links-from-others [ set weight precision (others-weight / norm) 100 ]
;  ]
  
  ask turtles [ 
    set self-weight (1 - get-in-neighbour-weights)
  ]
  
end

